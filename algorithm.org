#+title: Notes
This post is my notes for preparing a coding interview, 
including some thoughts about classic problems, 
and some terminologies that might be necessary for an interview.
* sort
** heap
**Heap is a good choice if just want the top K elements and do not want to sort**
*** some STL support
- ~make_heap~ to build a **max* heap using ~operator<~
- ~push_heap~ to add a new element
- ~pop_heap~ to remove the first element, will sort the next element automatically


#+BEGIN_SRC C++ :flags -std=c++11 :includes <algorithm> <iostream> <vector> :namespaces std
  using namespace std;

  vector<int> arr({4, 3, 5, 8, 1, 3, 2});
  make_heap(arr.begin(), arr.end());

  cout << "after build" << endl;
  for (auto i : arr) {
    cout << i << " ";
  }
  cout << endl;

  int nnums = arr.size();
  for (int i = 0; i < nnums; i++) {
    pop_heap(arr.begin(), arr.end());
    cout << "the 1-th is " << arr.back() << endl;
    arr.pop_back();
  }
#+END_SRC

#+RESULTS:
| after | build |    |   |   |   |   |
| 8     | 4     | 5  | 3 | 1 | 3 | 2 |
| the   | 1-th  | is | 8 |   |   |   |
| the   | 1-th  | is | 5 |   |   |   |
| the   | 1-th  | is | 4 |   |   |   |
| the   | 1-th  | is | 3 |   |   |   |
| the   | 1-th  | is | 3 |   |   |   |
| the   | 1-th  | is | 2 |   |   |   |
| the   | 1-th  | is | 1 |   |   |   |

* binary operations
The basic binary operations are as follows

| ~<<~  | left shift                 | ~1<<2~ gets 2         |
| ~>>~  | right shift                | ~4>>2~ gets 1         |
| ~&~   | bitwise and                | ~0 & 1 = 0~           |
| \vert | bitwise or                 |                       |
| ~~~   | bitwise complement         | ~unsigned int max=~0~ |
| ~^~   | bitwise Exclusive-Or (XOR) | ~10^11=01~            |
** set some bit
#+BEGIN_SRC C++
  x |= 1 << n;
#+END_SRC
** reset some bit
#+BEGIN_SRC C++
  x &= (~0 ^ (1<<n))
#+END_SRC
** check some bit
#+BEGIN_SRC C++
  x & (1<<n)
#+END_SRC

** bitset
Bitset is a c++ container for bits.
*** operators
| ~test~      | access the specific bit                             |
| ~all~       | check if all bits are set to ~true~                 |
| ~any~       |                                                     |
| ~none~      |                                                     |
| ~count~     | returns the number of bits set to ~true~            |
| ~size~      | return the size number of bits that bitset can hold |
| ~set~       | sets bits to ~true~ or gien value                   |
| ~reset~     | sets bits to ~false~                                |
| ~flip~      | toggles the values of bits                          |
| ~to_string~ | returns a string representation of the data         |
| ~to_ulong~  |                                                     |
| ~to_ullong~ |                                                     |
| ~&~         |                                                     |
| \vert       |                                                     |
| ~^~         |                                                     |
| ~<<~        |                                                     |
| ~>>~        |                                                     |

#+BEGIN_SRC C++ :includes <iostream> <bitset> :flags -std=c++11 :namespaces std
  using namespace std;

  bitset<16> bits;
  bits.set(1);
  bits.set(3);
  bits.set(5);

  cout << bits.to_string() << endl;
  cout << "~ " << bits.flip().to_string() << endl;
#+END_SRC

#+RESULTS:
| 101010 |                  |
|      ~ | 1111111111010101 |
** storeage of negative numbers
A positive number is representated as itself while a negative number 
is representated as the two's complement of its absolute value.

In other words, the binary representation of -K as a N-bit number is concat(1, 2^(N-1)-K). 
The absolute value should be ~~abs + 1~ , for example, the ~-3~ with 4 bits will be expressed as ~1101~.

To plus one positive number plus one negative number simply plus each bit of the numbers.
** classicial problems
*** XOR
- Single Number
  - Given an array of integers, every element appears twice except one.
- Single Number II
  - Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
- Single Number III
  - Given an array of numbers ~nums~, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
  
**Some general ideas**

- the XOR(exclusive-or) operation on two same numbers will be zero.
- counters on integers' bits have ~O(1)~ storage complexity, while the ones on integers will get `O(n)~.
  
*** bits as tiny set (which has less than 32 or 64 entries)
If a key that has less than 64 keys is needed, an `long long` or `int` can be used.
By using an ~unsigned int~ or ~unsigned long long~, one can get a set with constant memroy.

The bitset can be used too, and the number ob bits can be more than 32, but its size is fixed.
*** bit as group
https://leetcode.com/problems/total-hamming-distance/discuss/
* Linked list
* trees
** top to bottom or bottom to top
If we want to traverse a tree, from top to bottom is ok; if to generate multiple trees, 
from bottom to top should be easier, use a vector to store subtrees.

[Unique Binary Search TreeII](https://leetcode.com/problems/unique-binary-search-trees-ii/description/)

** TODO
- https://leetcode.com/problemset/algorithms/?difficulty=Medium
* Dynamic Programming
** find the maximum or longest
if the recursive branchs' result conflits with each other, 
the recursive function should return a complete result and the caller frame should compare them.

https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/
** classical problems
*** boundary related sum or product
- product of array except self
*** states based on previous
*** maximum
- https://leetcode.com/problems/maximum-length-of-pair-chain/description/
* Careful problems
- [LRU Cache](https://leetcode.com/problems/lru-cache/description/)
  - Least Recent Used, out
    - If get/set, put it to the head
    - much linked-list operations, should be quite careful
  - there are a number of Cache replacement policies
  - FIFO
* Terminologies
in-order traversal
* Randoms
<stdlib.h>
<time.h>
srand(time(0));
rand() 
RAND_MAX
