#+title: Notes
This post is my notes for preparing a coding interview, 
including some thoughts about classic problems, 
and some terminologies that might be necessary for an interview.
* skills
** use special marks to avoid duplicate searching
for example, breadth-first search in a matrix, to avoid repeatly searhcing the same element,

1. replace the element with a special token such as `#`
2. recursive search the next step
3. restore the element

* tree traversal
- [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)
- [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)
- [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)
- [good solution without recursion](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/)
** initializing variables
It is a bad idea to initialize variables to MAX or MIN of a type, for MIN and MAX are within the boundary.

Better to init them with some logic impossible cases, such as a data structure that has a `begin` and `end`,
set `end<begin`, it is simple to check whether this is the initialization.
** priority queue
<queue>
- push
- pop
- top
- customize compare
  #+BEGIN_SRC C++
    auto cmp = [](int a, int b) {
      return a < b;
    };
    // max queue
    std::priority_queue<int, vector<int>, decltype(cmp)> queue(cmp);

    // visit top
    queue.top()
  #+END_SRC
** avoid overflow
*** safe way to get median
~(end - begin)/2 + begin~
* types
* sort
** heap
**Heap is a good choice if just want the top K elements and do not want to sort**
*** some STL support
- ~make_heap~ to build a **max* heap using ~operator<~
- ~push_heap~ to add a new element
- ~pop_heap~ to remove the first element, will sort the next element automatically

  #+BEGIN_SRC C++
    // default max heap
    vector<int> heap;
    make_heap(heap.begin(), heap.end());
    int v0 = heap.back();
    // move value to the back
    pop_heap(heap.begin(), heap.end());
    heap.pop_back();

    // put new value to the back
    // push heap will rebuild the heap with the new value
    heap.push_back(7);
    push_heap(heap.begin(), heap.end());
  #+END_SRC

#+BEGIN_SRC C++ :flags -std=c++11 :includes <algorithm> <iostream> <vector> :namespaces std
  using namespace std;

  vector<int> arr({4, 3, 5, 8, 1, 3, 2});
  make_heap(arr.begin(), arr.end());

  cout << "after build" << endl;
  for (auto i : arr) {
    cout << i << " ";
  }
  cout << endl;

  int nnums = arr.size();
  for (int i = 0; i < nnums; i++) {
    pop_heap(arr.begin(), arr.end());
    cout << "the 1-th is " << arr.back() << endl;
    arr.pop_back();
  }
#+END_SRC

#+RESULTS:
| after | build |    |   |   |   |   |
| 8     | 4     | 5  | 3 | 1 | 3 | 2 |
| the   | 1-th  | is | 8 |   |   |   |
| the   | 1-th  | is | 5 |   |   |   |
| the   | 1-th  | is | 4 |   |   |   |
| the   | 1-th  | is | 3 |   |   |   |
| the   | 1-th  | is | 3 |   |   |   |
| the   | 1-th  | is | 2 |   |   |   |
| the   | 1-th  | is | 1 |   |   |   |
* search
** search in ordered
- [search a 2D matrixII](https://leetcode.com/problems/search-a-2d-matrix-ii/description/)
* Array and sequence
** parse complex format
~stream~ can help to parse some formats, for example, read a fraction

#+BEGIN_SRC C++
  stringstream is;
  is << str;

  int numerator;
  int dominator;
  char _;

  is >> numerator >> _ >> dominator;
#+END_SRC
** TODO scanf and cin to split string.
https://leetcode.com/problems/fraction-addition-and-subtraction/description/

** production or sum of subarray
- [max product subarray](https://leetcode.com/problems/maximum-product-subarray/description/)
** TODO binary search and get min/max than this num
** ~nth_element~ in O(n)
** find peak
the core idea is to find the local maximum.

be careful that in binary search, the mid should be less than end, but may be equal begin,
so compare ~nums[mid]~ and ~nums[mid+1]~ should be more safe.
https://leetcode.com/problems/find-peak-element/description/
** subsequence related
- [maximum size of subarray sum equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/)
* binary operations
The basic binary operations are as follows

| ~<<~  | left shift                 | ~1<<2~ gets 2         |
| ~>>~  | right shift                | ~4>>2~ gets 1         |
| ~&~   | bitwise and                | ~0 & 1 = 0~           |
| \vert | bitwise or                 |                       |
| ~~~   | bitwise complement         | ~unsigned int max=~0~ |
| ~^~   | bitwise Exclusive-Or (XOR) | ~10^11=01~            |
** set some bit
#+BEGIN_SRC C++
  x |= 1 << n;
#+END_SRC
** reset some bit
#+BEGIN_SRC C++
  x &= (~0 ^ (1<<n))
#+END_SRC
** check some bit
#+BEGIN_SRC C++
  x & (1<<n)
#+END_SRC

** bitset
Bitset is a c++ container for bits.
*** operators
| ~test~      | access the specific bit                             |
| ~all~       | check if all bits are set to ~true~                 |
| ~any~       |                                                     |
| ~none~      |                                                     |
| ~count~     | returns the number of bits set to ~true~            |
| ~size~      | return the size number of bits that bitset can hold |
| ~set~       | sets bits to ~true~ or gien value                   |
| ~reset~     | sets bits to ~false~                                |
| ~flip~      | toggles the values of bits                          |
| ~to_string~ | returns a string representation of the data         |
| ~to_ulong~  |                                                     |
| ~to_ullong~ |                                                     |
| ~&~         |                                                     |
| \vert       |                                                     |
| ~^~         |                                                     |
| ~<<~        |                                                     |
| ~>>~        |                                                     |

#+BEGIN_SRC C++ :includes <iostream> <bitset> :flags -std=c++11 :namespaces std
  using namespace std;

  bitset<16> bits;
  bits.set(1);
  bits.set(3);
  bits.set(5);

  cout << bits.to_string() << endl;
  cout << "~ " << bits.flip().to_string() << endl;
#+END_SRC

#+RESULTS:
| 101010 |                  |
|      ~ | 1111111111010101 |
** storeage of negative numbers
A positive number is representated as itself while a negative number 
is representated as the two's complement of its absolute value.

In other words, the binary representation of -K as a N-bit number is concat(1, 2^(N-1)-K). 
The absolute value should be ~~abs + 1~ , for example, the ~-3~ with 4 bits will be expressed as ~1101~.

To plus one positive number plus one negative number simply plus each bit of the numbers.
** classicial problems
*** XOR
- Single Number
  - Given an array of integers, every element appears twice except one.
- Single Number II
  - Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
- Single Number III
  - Given an array of numbers ~nums~, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
  
**Some general ideas**

- the XOR(exclusive-or) operation on two same numbers will be zero.
- counters on integers' bits have ~O(1)~ storage complexity, while the ones on integers will get `O(n)~.
  
*** bits as tiny set (which has less than 32 or 64 entries)
If a key that has less than 64 keys is needed, an `long long` or `int` can be used.
By using an ~unsigned int~ or ~unsigned long long~, one can get a set with constant memroy.

The bitset can be used too, and the number ob bits can be more than 32, but its size is fixed.
*** bit as group
https://leetcode.com/problems/total-hamming-distance/discuss/
* Linked List
* trees
** top to bottom or bottom to top
If we want to traverse a tree, from top to bottom is ok; if to generate multiple trees, 
from bottom to top should be easier, use a vector to store subtrees.

[Unique Binary Search TreeII](https://leetcode.com/problems/unique-binary-search-trees-ii/description/)

** TODO
- https://leetcode.com/problemset/algorithms/?difficulty=Medium
* BFS and DFS
- find the path to a destination
- [word ladder](https://leetcode.com/problems/word-ladder/description/)
- [word search](https://leetcode.com/problems/word-search/discuss/)
* Dynamic Programming
** find the maximum or longest
if the recursive branchs' result conflits with each other, 
the recursive function should return a complete result and the caller frame should compare them.

https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/
** classical problems
*** boundary related sum or product
- product of array except self
*** states based on previous
*** maximum
- https://leetcode.com/problems/maximum-length-of-pair-chain/description/
* math
** check element adjacement in a matrix
#+BEGIN_SRC C++
  using pos_t = pair<int, int>;

  (abs(pos1.first - pos2.first) == 1 && pos1.second == pos2.second) ||
  (abs(pos1.second - pos2.second) == 1 && pos1.second == pos2.second)
#+END_SRC

- [word search](https://leetcode.com/problems/word-search/description/)
** matrix
- [spiral matrix](https://leetcode.com/problems/spiral-matrix/description/)
** number represented by an array
- [next permutation](https://leetcode.com/problems/next-permutation/description/)
** Reservoir Sampling
*** TODO choose k samples
- the number of items is unknown.

- 1/k probability to select current item
- 1-1/k probability to drop current item
*** choose 1 sample
- count the items.
- sample the current item with probability 1/count
- ~rand() % count == count-1~
- https://leetcode.com/problems/linked-list-random-node/description/
*** distributed reservoir sampling
- split the original input to multiple parts
- remember each part size
- do reservoir sampling parally in multiple machines
- **merge the final samples with sampling weight of 1/size**
** greatest common divisor (GCD)
GCD can be used to represent the fraction that is hard to be transformed to be a decimal.
#+BEGIN_SRC python
  def gcd(a, b):
      while b != 0:
          t = b
          b = a % b
          a = t
      return a
#+END_SRC
** cycle detection
Floyd's algorIthm
Floyd's cycle-finding algorithm is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds.
#+BEGIN_SRC C++
  ListNode* findCircle(ListNode* head) {
    ListNode* slow = head, *fast = head;

    while (slow && fast) {
      if (fast != head && fast == slow) {
        fast = head;
        while(fast != slow) {
          fast = fast->next;
          slow = slow->next;
        }
        return fast;
      }
      // slow, one step
      slow = slow->next;
      // fast, two steps
      fast = fast->next;
      if (!fast) return nullptr;
      fast = fast->next;
    }
    return nullptr;
  }
#+END_SRC


* Careful problems
- [LRU Cache](https://leetcode.com/problems/lru-cache/description/)
  - Least Recent Used, out
    - If get/set, put it to the head
    - much linked-list operations, should be quite careful
  - there are a number of Cache replacement policies
  - FIFO
* Terminologies
in-order traversal
* Randoms
<stdlib.h>
<time.h>
srand(time(0));
rand() 
RAND_MAX
